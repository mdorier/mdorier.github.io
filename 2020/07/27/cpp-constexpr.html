<!DOCTYPE html>
<html prefix="og: https://ogp.me/ns#">
  <head>

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="">
  <meta name="author" content="Matthieu Dorier">
	<meta property='og:title' content='Using C++17 metaprogramming to compute a function's signature at compile time'/>
	<meta property='og:url' content='https://mdorier.github.io/2020/07/27/cpp-constexpr.html'/>
	<meta property='og:image' content=''/>
	<meta property='og:description' content="Matthieu Dorier's Blog"/>

  <title>Matthieu Dorier's website</title>

  <!-- Bootstrap core CSS -->
  <link href="/vendor/bootstrap/css/bootstrap.min.css" rel="stylesheet">

  <!-- Custom fonts for this template -->
  <link href="https://fonts.googleapis.com/css?family=Saira+Extra+Condensed:500,700" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css?family=Muli:400,400i,800,800i" rel="stylesheet">
  <link href="/vendor/fontawesome-free/css/all.min.css" rel="stylesheet">

  <!-- Custom styles for this template -->
  <link href="/assets/css/resume.css" rel="stylesheet">
  <link href="/assets/css/github-calendar-responsive.css" rel="stylesheet">
  <link href="/assets/css/highlight.css" rel="stylesheet">

  <link rel="icon" type="image/png" href="/assets/img/avatar.png">
</head>


  <body id="page-top">

    <nav class="navbar navbar-expand-lg navbar-dark bg-primary fixed-top" id="sideNav">
    <a class="navbar-brand js-scroll-trigger" href="#page-top">
      <span class="d-block d-lg-none">Matthieu Dorier</span>
      <span class="d-none d-lg-block">
        <img class="img-fluid img-profile rounded-circle mx-auto mb-2" src="/assets/img/avatar.png" alt="">
      </span>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav">
        <!-- Sections can be defined in _data/sections.yaml -->
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#about">About</a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#experience">Experience</a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#education">Education</a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#publications">Publications</a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#projects">Projects</a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#software">Software</a>
          </li>
        
          <li class="nav-item">
            <a class="nav-link js-scroll-trigger" href="/index.html#awards">Awards</a>
          </li>
        
        <!-- Blog is not a section but an actual link -->
          <li class="nav-item">
            <a class="nav-link" href="/blog.html">Blog</a>
          </li>
      </ul>
    </div>
</nav>


    <div class="container-fluid p-0">

    <hr class="m-0">

<section class="resume-section p-3 p-lg-5 d-flex">
  <div class="w-100">
    <h2 class="mb-5">Using C++17 metaprogramming to compute a function's signature at compile time</h2>
    <h4>27 Jul 2020 - <span class="text-primary">Matthieu</span></h4>
    <p>Constructing a string that represents a function’s signature in C++ is a common problem,
often showing up when wrapping low-level C libraries with higher-level, heavily-templated
C++ code. One way of getting a type name in C++ is as follows:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="n">x</span><span class="p">).</span><span class="n">name</span><span class="p">();</span></code></pre></figure>

<p>Where <code class="language-plaintext highlighter-rouge">x</code> is the variable whose type name you want. Let’s use that for a function:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span><span class="p">,</span> <span class="kt">char</span><span class="o">&amp;&amp;</span><span class="p">,</span> <span class="kt">long</span><span class="o">*</span><span class="p">,</span> <span class="kt">char</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">4</span><span class="p">]);</span>
<span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="k">typeid</span><span class="p">(</span><span class="n">f</span><span class="p">).</span><span class="n">name</span><span class="p">();</span></code></pre></figure>

<p>When we print out the <code class="language-plaintext highlighter-rouge">name</code> however, we get <code class="language-plaintext highlighter-rouge">FvRKiOcPlPA4_cE</code>. Ouch!
Quoting <a href="https://en.cppreference.com/w/cpp/types/type_info/name">cppreference</a>:</p>

<p><em>Some implementations (such as MSVC, IBM, Oracle) produce a human-readable type name.
Others, most notably gcc and clang, return the mangled name, which is specified by the Itanium C++ ABI.</em></p>

<p>While we could go an use something like <code class="language-plaintext highlighter-rouge">boost::core::demangle</code> to produce a
readable name, the whole type_info/demangle machinery works at run time. What
if we want the string <em>at compile time</em>? And what if we want to customize it?
An example would be returning <code class="language-plaintext highlighter-rouge">"%d, %f -&gt; %c"</code> when given a function
that looks like <code class="language-plaintext highlighter-rouge">char f(int, float)</code>, as a way to produce a formatting string
for a C-style logger.</p>

<p>This problem got me interested, so in this post I’ll show you how to produce 
a function’s signature at compile time in C++17, using a mix of <em>templates</em>,
<em>constexpr</em>, and <em>type traits</em>.</p>

<h3 id="writing-a-type_name-structure">Writing a <code class="language-plaintext highlighter-rouge">type_name</code> structure</h3>

<p>The problem we want to solve consists of writing a <code class="language-plaintext highlighter-rouge">type_name</code> template structure
with a <code class="language-plaintext highlighter-rouge">get</code> static function, such that for any type <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">type_name&lt;T&gt;::get()</code>
will return a string name. Let’s start with its declaration.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="p">;</span></code></pre></figure>

<p>The use of a variadic template will make sense later. We now need to
specialize this template structure for various types, and provide the <code class="language-plaintext highlighter-rouge">get</code>
function in these specializations.</p>

<p>In C++17, <code class="language-plaintext highlighter-rouge">std::string</code> doesn’t have constexpr constructors, so we can’t have <code class="language-plaintext highlighter-rouge">get</code>
return an <code class="language-plaintext highlighter-rouge">std::string</code>. We cannot return a <code class="language-plaintext highlighter-rouge">char[]</code> either. So we first need to
write a little <code class="language-plaintext highlighter-rouge">constexpr_string</code> structure to hold strings that can be constructed
and returned in a constexpr context.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span> <span class="o">&lt;</span><span class="kt">unsigned</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">constexpr_string</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">value</span><span class="p">[</span><span class="n">N</span><span class="p">];</span>
<span class="p">};</span></code></pre></figure>

<p>Since we are not going to use <code class="language-plaintext highlighter-rouge">typeid</code>, we need to provide the name of simple
types ourselves. Let’s specialize our <code class="language-plaintext highlighter-rouge">type_name</code> structure for simple types,
for example <code class="language-plaintext highlighter-rouge">int</code>:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">constexpr_string</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"int"</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>In fact, let’s make this a macro, so we can call it for other basic types
(or any classes to which we want to provide a name).</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="cp">#define REGISTER_TYPE_NAME(__type__) \
    template&lt;&gt; struct type_name&lt;__type__&gt; { \
        constexpr static auto get() { \
            return constexpr_string&lt;sizeof #__type__&gt;{#__type__}; \
        } \
    }
</span>
<span class="n">REGISTER_TYPE_NAME</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">REGISTER_TYPE_NAME</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
<span class="n">REGISTER_TYPE_NAME</span><span class="p">(</span><span class="kt">char</span><span class="p">);</span>
<span class="n">REGISTER_TYPE_NAME</span><span class="p">(</span><span class="kt">long</span><span class="p">);</span>
<span class="n">REGISTER_TYPE_NAME</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
<span class="n">REGISTER_TYPE_NAME</span><span class="p">(</span><span class="kt">float</span><span class="p">);</span></code></pre></figure>

<p>We could register names for a bunch of other basic types, but let’s leave it at
that for the moment.</p>

<p>Let’s also provide a specialization for any type not registered:</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">constexpr_string</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"&lt;unknown&gt;"</span><span class="p">};</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<h3 id="concatenating-constexpr_strings">Concatenating <code class="language-plaintext highlighter-rouge">constexpr_string</code>s</h3>

<p>If we want to display multiple type, as is typical in a function signature, we
will need to concatenate <code class="language-plaintext highlighter-rouge">constexpr_string</code>s. This can be done in a constexpr
context as follows.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="p">...</span><span class="n">L</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">cat</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">...</span><span class="n">strings</span><span class="p">)[</span><span class="n">L</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="n">N</span> <span class="o">=</span> <span class="p">(...</span> <span class="o">+</span> <span class="n">L</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">...(</span><span class="n">L</span><span class="p">);</span>
    <span class="n">constexpr_string</span><span class="o">&lt;</span><span class="n">N</span> <span class="o">+</span> <span class="mi">1</span><span class="o">&gt;</span> <span class="n">result</span> <span class="o">=</span> <span class="p">{};</span>
    <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">[</span><span class="n">N</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="kt">char</span><span class="o">*</span> <span class="n">dst</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">src</span> <span class="o">:</span> <span class="p">{</span><span class="n">strings</span><span class="p">...})</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">src</span> <span class="o">!=</span> <span class="sc">'\0'</span><span class="p">;</span> <span class="n">src</span><span class="o">++</span><span class="p">,</span> <span class="n">dst</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>Let’s dive a little into this function: it takes as parameters
an arbitrary number of <code class="language-plaintext highlighter-rouge">char</code> arrays (we will use that so we can directly
pass string litterals as well). It then computes <code class="language-plaintext highlighter-rouge">N</code> as the sum of the lengths
of all the input strings (sing a fold-expression) , minus the number of
strings (to remove the trailing null-terminator of each string).
It initializes the <code class="language-plaintext highlighter-rouge">result</code> string with a
length of <code class="language-plaintext highlighter-rouge">N+1</code> (to accomodate for <code class="language-plaintext highlighter-rouge">result</code>’s own null-terminator, which
is assigned next). It then iterates over all the input strings, and over
all their characters, to copy them into the result. All of this can be done
at compile time.</p>

<h3 id="printing-a-list-of-type-names">Printing a list of type names</h3>

<p>Using the above <code class="language-plaintext highlighter-rouge">cat</code> function, we can now specialize our <code class="language-plaintext highlighter-rouge">type_name</code> structure
to handle a list of template parameters with more than one type. In this example
we will add a <code class="language-plaintext highlighter-rouge">", "</code> separator between them.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T1</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">Other</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="n">T1</span><span class="p">,</span> <span class="n">Other</span><span class="p">...</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">T1</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">", "</span><span class="p">,</span>
                   <span class="n">type_name</span><span class="o">&lt;</span><span class="n">Other</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>We can now specialize the <code class="language-plaintext highlighter-rouge">type_name</code> for functions by using the above specialization
to get a comma-separated list of argument types, preceded and followed by parenthesis,
and follows by the type of the return value.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">R</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="n">R</span><span class="p">(</span><span class="n">T</span><span class="p">...)</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="s">"("</span><span class="p">,</span> <span class="n">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="p">...</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">")"</span><span class="p">,</span>
                   <span class="s">" -&gt; "</span><span class="p">,</span> <span class="n">type_name</span><span class="o">&lt;</span><span class="n">R</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>Now if we declare <code class="language-plaintext highlighter-rouge">double f(int, char)</code> and call <code class="language-plaintext highlighter-rouge">type_name&lt;decltype(f)&gt;::get().value</code>
we obtain <code class="language-plaintext highlighter-rouge">"(int, char) -&gt; double"</code>.</p>

<h3 id="handling-const-references-pointers-etc">Handling const, references, pointers, etc.</h3>

<p>If we try what we have coded so far with <code class="language-plaintext highlighter-rouge">double&amp; f(const int&amp;, char&amp;&amp;, float*, long[2][3])</code>,
we obtain… <code class="language-plaintext highlighter-rouge">"(&lt;unknown&gt;, &lt;unknown&gt;, &lt;unknown&gt;, &lt;unknown&gt;) -&gt; &lt;unknown&gt;"</code>. Very helpful…
This is because while we have registered the basic types, we haven’t registered references
to these types, or pointers, or arrays. We can fix that we going back to our specialization
of <code class="language-plaintext highlighter-rouge">type_name</code> that took a single <code class="language-plaintext highlighter-rouge">T</code> parameter, and use type traits along with constexpr if
statements to detect these modifiers.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_pointer_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">"*"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_const_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="s">"const "</span><span class="p">,</span> <span class="n">type_name</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_const_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_rvalue_reference_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">"&amp;&amp;"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_lvalue_reference_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_reference_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">"&amp;"</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">constexpr_string</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"&lt;unknown&gt;"</span><span class="p">};</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>Now we get <code class="language-plaintext highlighter-rouge">"(const int&amp;, char&amp;&amp;, float*, &lt;unknown&gt;*) -&gt; double&amp;"</code>. Why is <code class="language-plaintext highlighter-rouge">long[2][3]</code>
transformed into <code class="language-plaintext highlighter-rouge">&lt;unknown&gt;*</code>? Well, because <code class="language-plaintext highlighter-rouge">long[2][3]</code> decayes into <code class="language-plaintext highlighter-rouge">long[2]*</code>, not
into <code class="language-plaintext highlighter-rouge">long**</code>, and our code doesn’t know how to handle arrays. We need to add support for
arrays, as follows.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[]</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">"[]"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="p">[</span><span class="n">N</span><span class="p">]</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="k">static</span> <span class="k">auto</span> <span class="n">get</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">cat</span><span class="p">(</span><span class="n">type_name</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">get</span><span class="p">().</span><span class="n">value</span><span class="p">,</span> <span class="s">"[]"</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span></code></pre></figure>

<p>We now have the following signature: <code class="language-plaintext highlighter-rouge">"(const int&amp;, char&amp;&amp;, float*, long[]*) -&gt; double&amp;"</code>.
This mechanism ignores the length of the array <code class="language-plaintext highlighter-rouge">N</code> and just prints <code class="language-plaintext highlighter-rouge">[]</code>. I leave it as
an exercise to the reader to come up with a mechanism that builds a <code class="language-plaintext highlighter-rouge">constexpr_string</code>
decimal representation of <code class="language-plaintext highlighter-rouge">N</code> in a constexpr context. If you understood the code above,
and have some knowledge of constexpr, templates, and C++17 metaprogramming in general,
you will surely find the solution.</p>

<p>There are of course some more details to take into considerations, such as handling
member object/function pointers (with <code class="language-plaintext highlighter-rouge">std::is_member_object_pointer</code> and
<code class="language-plaintext highlighter-rouge">std::is_member_function_pointer</code>), or properly displaying functions that take
a function pointer as argument (for instance <code class="language-plaintext highlighter-rouge">void g(int (*)(char, char))</code>
is shown to have the type <code class="language-plaintext highlighter-rouge">"((char, char) -&gt; int*) -&gt; void"</code>, which looks
like it takes a function that returns an <code class="language-plaintext highlighter-rouge">int*</code>, instead of a pointer to a function
that returns an <code class="language-plaintext highlighter-rouge">int</code>).</p>

<p>If you want to try the code of this blog post for yourself, you can head
<a href="https://godbolt.org/z/vh7zaW5sn" target="_blank">here</a>
and you’ll see from the assembly that all of this does compute the signature
at compile time.</p>


    <script src="https://utteranc.es/client.js"
        repo="mdorier/mdorier.github.io"
        issue-term="pathname"
        label="Comment"
        theme="github-light"
        crossorigin="anonymous"
        async>
    </script>

  </div>
</section>
<hr class="m-0">


    </div>

      <!-- Bootstrap core JavaScript -->
  <script src="/vendor/jquery/jquery.min.js"></script>
  <script src="/vendor/bootstrap/js/bootstrap.bundle.min.js"></script>

  <!-- Plugin JavaScript -->
  <script src="/vendor/jquery-easing/jquery.easing.min.js"></script>

  <!-- Custom scripts for this template -->
  <script src="/assets/js/resume.min.js"></script>


  </body>

</html>
